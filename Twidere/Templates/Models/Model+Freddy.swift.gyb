%{
import yaml
from collections import OrderedDict

def ordered_load(stream, Loader=yaml.Loader, object_pairs_hook=OrderedDict):
    class OrderedLoader(Loader):
        pass
    def construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return object_pairs_hook(loader.construct_pairs(node))
    OrderedLoader.add_constructor(yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping)
    return yaml.load(stream, OrderedLoader)

with open(modelPath, 'r') as f:
    modelDef = ordered_load(f, yaml.SafeLoader)
    importNames = modelDef.get('imports', [])

def generateEnumContent(name, outerName, model):
    className = name
    if outerName is not None:
        className = '{outer}.{inner}'.format(outer=outerName, inner=name)
    return """
extension {className}: JSONDecodable, JSONEncodable {{}}
    """.format(
        className = className
    )

def generateModelContent(name, modelType, outerName, model):
    className = name
    if outerName is not None:
        className = '{outer}.{inner}'.format(outer=outerName, inner=name)
    initLines = []
    toJsonLines = []
    fields = model['fields']
    for propertyName in fields:
        field = fields[propertyName]
        jsonField = field.get('json_field', None)

        propertyType = field['type']
        jsonTransform = field.get('json_transform', None)
        jsonNull = field.get('json_null', 'omit')
        isArray = False
        isOptional = False
        if propertyType.endswith('?') or propertyType.endswith('!') :
            propertyType = propertyType[:-1]
            # isOptional = True
        if propertyType.startswith('['):
            # propertyType = propertyType[1:-1]
            isArray = True
        if (jsonField is None):
            fieldInit = field.get('init', 'nil')
            initLines.append("        obj.{propertyName} = {fieldInit}"
                .format(propertyName=propertyName, fieldInit=fieldInit))
            continue
        if isOptional:
            tryClause = 'try?'
        else:
            tryClause = 'try'
        if isArray:
            getMethod = "value.decodedArray(at: \"{jsonField}\")".format(jsonField=jsonField)
        else:
            getMethod = "value.decode(at: \"{jsonField}\")".format(jsonField=jsonField)
        if modelType == 'struct':
            initLines.append("        self.{propertyName} = {tryClause} {getMethod}"
                .format(propertyName=propertyName, propertyType=propertyType, tryClause=tryClause, getMethod=getMethod))
        else:
            initLines.append("        let {propertyName}: {propertyType} = {tryClause} {getMethod}"
                .format(propertyName=propertyName, propertyType=propertyType, tryClause=tryClause, getMethod=getMethod))

        if not isOptional:
            toJsonLines.append("        dict[\"{jsonField}\"] = self.{propertyName}.toJSON()".format(jsonField=jsonField, propertyName=propertyName))
        elif jsonNull == 'omit':
            pass
        elif jsonNull == 'force':
            toJsonLines.append("        dict[\"{jsonField}\"] = self.{propertyName}!.toJSON()".format(jsonField=jsonField, propertyName=propertyName))
        else:
            toJsonLines.append("        dict[\"{jsonField}\"] = self.{propertyName}?.toJSON()".format(jsonField=jsonField, propertyName=propertyName))

    if modelType == 'struct':
        decodeProtocol = 'JSONDecodable'
        decodeContent = """
    init(json value: JSON) throws {{
{initContent}
    }}
""".format(initContent='\n'.join(initLines))
    else:
        decodeProtocol = 'JSONStaticDecodable'
        decodeContent = """
    static func fromJSON(json value: JSON) throws -> {modelName} {{
        var obj = {modelName}()
{initContent}
        return obj
    }}
""".format(modelName=className, initContent='\n'.join(initLines))
    subModelsLines = []
    submodels = model.get('submodels', [])
    for subModelName in submodels:
        submodel = submodels[subModelName]
        subModelType = submodel.get('type', 'class')
        if not model.get('mapable', True):
            continue
        if subModelType == 'enum':
            subModelsLines.append(generateEnumContent(
                name = subModelName,
                outerName = className,
                model = submodel
            ))
        else:
            subModelsLines.append(generateModelContent(
                name = subModelName,
                modelType = subModelType,
                outerName = className,
                model = submodel
            ))
    classTemplate = """extension {modelName}: {decodeProtocol} {{
{decodeContent}
}}

extension {modelName}: JSONEncodable {{
    public func toJSON() -> JSON {{
        var dict: [String: JSON] = [:]
//{{toJsonContent}}
        return .dictionary(dict)
    }}
}}
{subModelsContent}
""".format(
        modelName=className,
        decodeContent=decodeContent,
        decodeProtocol=decodeProtocol,
        toJsonContent='\n'.join(toJsonLines),
        subModelsContent='\n'.join(subModelsLines)
    )
    classLines = classTemplate.splitlines()
    return '\n'.join(classLines)
}%
// Automatically generated, DO NOT MODIFY
import Freddy
% for importName in importNames:
import ${importName}
%end

% rootModels = modelDef['submodels']
% for modelName in rootModels:
    % model = rootModels[modelName]
    % modelType = model.get('type', 'class')
    % if model.get('mapable', True):
        % if modelType == 'enum':
${generateModelContent(name = modelName, outerName = None, model = model)}
        %else:
${generateModelContent(name = modelName, modelType = modelType, outerName = None, model = model)}
        %end
    %end
%end
