%{
    import yaml
    from collections import OrderedDict

    def ordered_load(stream, Loader=yaml.Loader, object_pairs_hook=OrderedDict):
        class OrderedLoader(Loader):
            pass
        def construct_mapping(loader, node):
            loader.flatten_mapping(node)
            return object_pairs_hook(loader.construct_pairs(node))
        OrderedLoader.add_constructor(yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, construct_mapping)
        return yaml.load(stream, OrderedLoader)

    with open(modelPath, 'r') as f:
        model = ordered_load(f, yaml.SafeLoader)
        fields = model['fields']
        submodels = model.get('submodels', [])
        importNames = model.get('imports', [])
        className = model['name']
}%
import MessagePack_swift

% for importName in importNames:
import ${importName}
%end

extension ${className} {

    convenience init(_ value: MessagePackValue) {
        value.dictionaryValue?.forEach { k, v in
            guard let ks = k.stringValue else {
                return
            }
            switch ks {
            % for propertyName in fields:
            % propertyType = fields[propertyName]['type']
            % if propertyType.endswith('?') or propertyType.endswith('!') :
            % propertyType = propertyType[:-1]
            %end
            % propertyType = propertyType[0].lower() + propertyType[1:]
            case "${propertyName}":
                self.${propertyName} = v.${propertyType}Value
            %end
            default: break
            }
        }
    }

    func messagePackValue() -> MessagePackValue {
        var map: [MessagePackValue: MessagePackValue] = [:]
        % for propertyName in fields:
        if (self.${propertyName} != nil) {
            map[.String("${propertyName}")] = MessagePackValue(self.${propertyName}!)
        }
        %end
        return map
    }

}

extension MessagePackValue {
    init(_ value: ${className}) {
        self = value.messagePackValue()
    }

    % varName = className[0].lower() + className[1:]
    var ${varName}Value: ${className}? {
        switch self {
        case let .Map(map):
            return ${className}(map)
        default:
            return nil
        }
    }
}


% for subModelName in submodels:
extension ${className}.${subModelName} {
% subModelFields = submodels[subModelName]['fields']

    convenience init(_ value: MessagePackValue) {
        value.dictionaryValue?.forEach { k, v in
            guard let ks = k.stringValue else {
                return
            }
            switch ks {
            % for propertyName in subModelFields:
            % propertyType = subModelFields[propertyName]['type']
            % if propertyType.endswith('?') or propertyType.endswith('!') :
            % propertyType = propertyType[1:]
            %end
            % propertyType = propertyType[0].lower() + propertyType[1:]
            case "${propertyName}":
                self.${propertyName} = v.${propertyType}Value
            %end
            default: break
            }
        }
    }

    func messagePackValue() -> MessagePackValue {
        var map: [MessagePackValue: MessagePackValue] = [:]
        % for propertyName in subModelFields:
        if (self.${propertyName} != nil) {
            map[.String("${propertyName}")] = MessagePackValue(self.${propertyName}!)
        }
        %end
        return map
    }
}

extension MessagePackValue {
    init(_ value: ${className}.${subModelName}) {
        self = value.messagePackValue()
    }

    % varName = className[0].lower() + className[1:] + subModelName
    var ${varName}Value: ${className}.${subModelName}? {
        switch self {
        case let .Map(map):
            return ${className}.${subModelName}(map)
        default:
            return nil
        }
    }
}
%end
